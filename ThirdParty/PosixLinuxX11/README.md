# Bionic-based Linux  

Since the version of **glibc** and **stdc++** varies a lot among different Linux distributions, the binaries built on one Linux distribution are hardly able to run stably and with the same behavior on another Linux distribution without rebuild.  
  
Most softwares on Linux are open source and the developers expect the end users to download the the source code and then build and install on their local Linux distributions(the famous "make install" command) and care little about providing prebuilt binaries to end users.  
  
Therefore, we use Android's [bionic](https://android.googlesource.com/platform/bionic)\(-android-7.1.2_r39\) to ensure that the binaries generated by a single build are able to run stably and with the same behavior on any Linux distributions.  
  
Referring to the official document [Building Open Source Projects Using Standalone Toolchains](https://developer.android.com/ndk/guides/standalone_toolchain#building_open_source_projects_using_standalone_toolchains) provided by Google, we built all third-party libraries ([X11](/ThirdParty/PosixLinuxX11/Bionic-Build/X11-README.md), [Mesa-Vulkan-Drivers](/ThirdParty/PosixLinuxX11/Bionic-Build/Mesa-README.md), [Vulkan-Loader](/ThirdParty/PosixLinuxX11/Bionic-Build/Vulkan-README.md), etc.) depended by PatriotEngine with the bionic\(-[ndk-r14b](https://developer.android.com/ndk/downloads/older_releases)\)-based toolchain.  
  
Using Andoird's bionic also provides another benefit: we can reuse the Android toolchain(ndk-build, etc.). In theory, we can use the same build system between Linux Desktop and Android, which saves the development time of PatriotEngine a lot.  
    
---      
[Bionic-based RenderDoc](https://github.com/YuqiaoZhang/Bionic-based-RenderDoc)    
     
---    

由于**glibc**和**stdc++**\的版本在不同Linux发行版之间差异较大，在一个Linux发行版上编译的二进制文件很难在未经重新编译的情况下在另一个Linux发行版上稳定并且行为一致地运行  

Linux上的软件都倾向于开源，开发者们普遍期望最终用户下载源代码后在本地编译安装(著名的make install命令)，而很少考虑提供预编译的二进制文件供最终用户使用  

因此，我们考虑到使用Android的[bionic](https://android.googlesource.com/platform/bionic)\(-android-7.0.0_r36\)，从而可以确保在一次编译后可以在任何的Linux发行版上稳定并且行为一致地运行  

参考google提供的官方文档[Building Open Source Projects Using Standalone Toolchains](https://developer.android.com/ndk/guides/standalone_toolchain#building_open_source_projects_using_standalone_toolchains)，我们基于bionic\(-[ndk-r14b](https://developer.android.com/ndk/downloads/older_releases)\)重新编译了PatriotEngine所依赖的所有第三方库（[X11](/ThirdParty/PosixLinuxX11/Bionic-Build/X11-README.md)、[Mesa-Vulkan-Drivers](/ThirdParty/PosixLinuxX11/Bionic-Build/Mesa-README.md)、[Vulkan-Loader](/ThirdParty/PosixLinuxX11/Bionic-Build/Vulkan-README.md)等)  

同时，使用Android的bionic还带来了一个潜在的好处：我们可以复用Android的工具链(ndk-build等)，理论上，Linux可以和Android共用同一套编译系统，大大减少了开发时间  

# create stand alone toolchain from ndk  
  
[Building Open Source Projects Using Standalone Toolchains](https://developer.android.com/ndk/guides/standalone_toolchain#building_open_source_projects_using_standalone_toolchains)  
    
```
target_arch=x86_64 ##x86 ##arm64 ##arm
target_host=x86_64-linux-android  ##i686-linux-android ##aarch64-linux-android ##arm-linux-androideabi

## Path for ndk ## default to c++shared
mv my-ndk-dir/sources/cxx-stl/llvm-libc++/libs/x86_64/libc++_static.a my-ndk-dir/sources/cxx-stl/llvm-libc++/libs/x86_64/libc++_static.a.bak
ln -s libc++_shared.so my-ndk-dir/sources/cxx-stl/llvm-libc++/libs/x86_64/libc++_static.a
mv my-ndk-dir/sources/cxx-stl/llvm-libc++/libs/x86/libc++_static.a my-ndk-dir/sources/cxx-stl/llvm-libc++/libs/x86/libc++_static.a.bak
ln -s libc++_shared.so my-ndk-dir/sources/cxx-stl/llvm-libc++/libs/x86/libc++_static.a

my-ndk-dir/build/tools/make-standalone-toolchain.sh --use-llvm --stl=libc++ --arch="$target_arch" --platform=android-24 --install-dir="$HOME/bionic-toolchain-$target_arch"

## Alternative (After make-standalone-toolchain) ## default to c++shared
rm -rf "$HOME/bionic-toolchain-x86_64/${target_host}/lib/libstdc++.a"
ln -s libc++_shared.so "$HOME/bionic-toolchain-x86_64/${target_host}/lib/libstdc++.a"

## Fix libcxx headers
in directory "include/c++/4.9", search "__ANDROID__" in headers
append "|| __linux && __BIONIC__"

## Patch for x86_64 
rm -rf "$HOME/bionic-toolchain-x86_64/sysroot/usr/lib"
rm -rf "$HOME/bionic-toolchain-x86_64/sysroot/usr/libx32"
mv "$HOME/bionic-toolchain-x86_64/sysroot/usr/lib64" "$HOME/bionic-toolchain-x86_64/sysroot/usr/lib"

rm -rf "$HOME/bionic-toolchain-x86_64/x86_64-linux-android/lib"
rm -rf "$HOME/bionic-toolchain-x86_64/x86_64-linux-android/libx32"
mv "$HOME/bionic-toolchain-x86_64/x86_64-linux-android/lib64" "$HOME/bionic-toolchain-x86_64/x86_64-linux-android/lib"

## Optional  
1. we can use the bionic built from aosp to replace the fake in toolchain 
2. we can delete the EGL GLES and vulkan in the toolchain sysroot which may conflict with mesa

```  

# general build rules

## build autoconf projects

Linux Version: EL8  
```
install autoconf automake libtool make el8 version ### there are bugs in el7 version ### use rpmrebuild to remove gcc dependency in libtool
rpm -e --nodeps gcc gcc-c++ kernel-headers glibc-headers glibc-devel libstdc++-devel ### 避免对sysroot造成干扰
```

Build projects  
```  
target_arch=x86_64 ##x86 ##arm64 ##arm
target_host=x86_64-linux-android  ##i686-linux-android ##aarch64-linux-android ##arm-linux-androideabi

# Add the standalone toolchain to the search path
export PATH="$HOME/bionic-toolchain-$target_arch/bin"${PATH:+:${PATH}}

# Tell configure what tools to use
# https://www.gnu.org/software/autoconf/manual/autoconf-2.66/html_node/Environment-Variable-Index.html
export AR=$target_host-ar
export AS=$target_host-clang
export CC=$target_host-clang
export CXX=$target_host-clang++
export LD=$target_host-ld
export STRIP=$target_host-strip

# Tell configure what flags Android requires
export CFLAGS="-fPIE -fPIC -U__ANDROID__ -UANDROID -D__BIONIC__=1"
export CXXFLAGS="-fPIE -fPIC -U__ANDROID__ -UANDROID -D__BIONIC__=1"
export LDFLAGS="-pie -Wl,--enable-new-dtags -Wl,-rpath,/XXXXXX -Wl,--no-undefined -lc++_shared" ### the linker can't recognize the old dtags ### chrpath can only make path shorter ### some undefined symbol like mblen

# pkg-config ### https://autotools.io/pkgconfig/cross-compiling.html
target_sysroot="$HOME/bionic-toolchain-$target_arch/sysroot"
export PKG_CONFIG_PATH=
export PKG_CONFIG_LIBDIR=${target_sysroot}/usr/lib/pkgconfig:${target_sysroot}/usr/share/pkgconfig
export PKG_CONFIG_SYSROOT_DIR=${target_sysroot}

# Autoconf
make clean
autoreconf -v --install --force -I"${target_sysroot}/usr/share/aclocal"  # From ./autogen.sh
./configure --prefix="$HOME/bionic-toolchain-$target_arch/sysroot/usr" --host=$target_host --disable-static
make install
```  

## build meson projects 

Linux Version: EL8  
```
yum install meson

delete python python2 python2.7 in "$HOME/bionic-toolchain-$target_arch/bin" ### meson use python3

delete clang clang++ in "$HOME/bionic-toolchain-$target_arch/bin"

rpm -e --nodeps gcc gcc-c++ kernel-headers glibc-headers glibc-devel libstdc++-devel ### avoid interfering the toolchain sysroot
```
  
  
Install bionic and libc++ from [https://github.com/YuqiaoZhang/Bionic-based-Linux/tree/rpms](https://github.com/YuqiaoZhang/Bionic-based-Linux/tree/rpms)   

```
meson will compile build-machine binaries and run them when call **project** in **meson.build** even if we are cross-building

we must copy the bionic to the /system path in able to pass the meson sanity check 
# the path "/system" is indicated by the program interpreter path "/system/bin/linker(64)" of the generated binaries  
# we can use "readelf -l .../a.out" to check the program interpreter path
```

build projects  
```  
target_arch=x86_64 ##x86 ##arm64 ##arm
target_host=x86_64-linux-android  ##i686-linux-android ##aarch64-linux-android ##arm-linux-androideabi

# Add the standalone toolchain to the search path.
export PATH="$HOME/bionic-toolchain-$target_arch/bin"${PATH:+:${PATH}}

# pkg-config ### https://autotools.io/pkgconfig/cross-compiling.html  
target_sysroot="$HOME/bionic-toolchain-$target_arch/sysroot"
export PKG_CONFIG_PATH=
export PKG_CONFIG_LIBDIR=${target_sysroot}/usr/lib/pkgconfig:${target_sysroot}/usr/share/pkgconfig
export PKG_CONFIG_SYSROOT_DIR=${target_sysroot}

# Add the standalone toolchain to the search path 

### meson will compile build-machine binaries when call **project** in **meson.build** even if it is cross build
export PATH="$HOME/meson-sanitycheck-$target_arch"${PATH:+:${PATH}}

### 

rm -rf "$HOME/meson-sanitycheck-$target_arch"
mkdir -p "$HOME/meson-sanitycheck-$target_arch"
echo '#!/bin/bash' > "$HOME/meson-sanitycheck-$target_arch"/clang ### add #!/bin.bash to avoid "Exec format error" from meson
echo "$target_host-clang -fPIE -fPIC -pie \"\$@\"" >> "$HOME/meson-sanitycheck-$target_arch"/clang
echo '#!/bin/bash' > "$HOME/meson-sanitycheck-$target_arch"/clang++ ### add #!/bin.bash to avoid "Exec format error" from meson
echo "$target_host-clang++ -fPIE -fPIC -pie \"\$@\"" >> "$HOME/meson-sanitycheck-$target_arch"/clang++
chmod +x "$HOME/meson-sanitycheck-$target_arch"/clang
chmod +x "$HOME/meson-sanitycheck-$target_arch"/clang++

# meson
## mkdir build
## cd build
## rm -rf *
meson .. --prefix="$HOME/bionic-toolchain-$target_arch/sysroot/usr" --buildtype=release  -Db_ndebug=true --cross-file="$HOME/bionic-toolchain-$target_arch/cross_file.txt" ### --reconfigure 

rm -rf "$HOME/meson-sanitycheck-$target_arch" ## the sanity check has finished 
ninja

```  
  
chrpath //fix me 

```
I don't know how to skip intall rpath in meson and I have to use the binaries under build/src
```

### -----------------------------------------------------------------------------------  

#### x86_64 cross file
```
[binaries]
ar = 'x86_64-linux-android-ar'
as = 'x86_64-linux-android-clang' 
c = 'x86_64-linux-android-clang'
cpp = 'x86_64-linux-android-clang++'
ld = 'x86_64-linux-android-ld'
strip = 'x86_64-linux-android-strip'
pkgconfig = 'pkg-config'

[properties]
c_args = ['-fPIE', '-fPIC', '-U__ANDROID__', '-UANDROID', '-D__BIONIC__=1']
c_link_args = ['-pie', '-Wl,--enable-new-dtags', '-Wl,-rpath,/XXXXXX', '-Wl,--no-undefined', '-lc++_shared'] ### -shared conflicts -pie ### results errors when use gcc
cpp_args = ['-fPIE', '-fPIC', '-U__ANDROID__', '-UANDROID', '-D__BIONIC__=1']
cpp_link_args = ['-pie', '-Wl,--enable-new-dtags', '-Wl,-rpath,/XXXXXX', '-Wl,--no-undefined', '-lc++_shared']

[host_machine]
system = 'linux'
cpu_family = 'x86_64'
cpu = 'x86_64'
endian = 'little'
```

#### x86 cross file
```
[binaries]
ar = 'i686-linux-android-ar'
as = 'i686-linux-android-clang' 
c = 'i686-linux-android-clang'
cpp = 'i686-linux-android-clang++'
ld = 'i686-linux-android-ld'
strip = 'i686-linux-android-strip'
pkgconfig = 'pkg-config'

[properties]
c_args = ['-fPIE', '-fPIC', '-U__ANDROID__', '-UANDROID', '-D__BIONIC__=1']
c_link_args = ['-pie', '-Wl,--enable-new-dtags', '-Wl,-rpath,/XXXXXX', '-Wl,--no-undefined', '-lc++_shared'] ### -shared conflicts -pie ### results errors when use gcc
cpp_args = ['-fPIE', '-fPIC', '-U__ANDROID__', '-UANDROID', '-D__BIONIC__=1']
cpp_link_args = ['-pie', '-Wl,--enable-new-dtags', '-Wl,-rpath,/XXXXXX', '-Wl,--no-undefined', '-lc++_shared']

[host_machine]
system = 'linux'
cpu_family = 'x86'
cpu = 'i686'
endian = 'little'
```

#### arm64 cross file
```
[binaries]
ar = 'aarch64-linux-android-ar'
as = 'aarch64-linux-android-clang'
c = 'aarch64-linux-android-clang'
cpp = 'aarch64-linux-android-clang++'
ld = 'aarch64-linux-android-ld'
strip = 'aarch64-linux-android-strip'

[properties]
c_args = ['-fPIE', '-fPIC', '-U__ANDROID__', '-UANDROID', '-D__BIONIC__=1']
c_link_args = ['-pie', '-Wl,--enable-new-dtags', '-Wl,-rpath,/XXXXXX', '-Wl,--no-undefined', '-lc++_shared']
cpp_args = ['-fPIE', '-fPIC', '-U__ANDROID__', '-UANDROID', '-D__BIONIC__=1']
cpp_link_args = ['-pie', '-Wl,--enable-new-dtags', '-Wl,-rpath,/XXXXXX', '-Wl,--no-undefined', '-lc++_shared']

[host_machine]
system = 'linux'
cpu_family = 'aarch64'
cpu = 'arm64'
endian = 'little'
```

## build cmake projects 


```  
target_arch=x86_64 ##x86 ##arm64 ##arm
target_host=x86_64-linux-android  ##i686-linux-android ##aarch64-linux-android ##arm-linux-androideabi

# Add the standalone toolchain to the search path
rm -rf "$HOME/cmake-$target_arch"
mkdir -p "$HOME/cmake-$target_arch"
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/ar
echo "$target_host-ar \"\$@\"" >> "$HOME/cmake-${target_arch}"/ar
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/as
echo "$target_host-clang \"\$@\"" >> "$HOME/cmake-${target_arch}"/as
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/cc
echo "$target_host-clang \"\$@\"" >> "$HOME/cmake-${target_arch}"/cc
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/c++
echo "$target_host-clang++ \"\$@\"" >> "$HOME/cmake-${target_arch}"/c++
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/ld
echo "$target_host-ld \"\$@\"" >> "$HOME/cmake-${target_arch}"/ld
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/strip
echo "$target_host-strip \"\$@\"" >> "$HOME/cmake-${target_arch}"/strip
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/nm
echo "$target_host-nm \"\$@\"" >> "$HOME/cmake-${target_arch}"/nm
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/objcopy
echo "$target_host-objcopy \"\$@\"" >> "$HOME/cmake-${target_arch}"/objcopy
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/objdump
echo "$target_host-objdump \"\$@\"" >> "$HOME/cmake-${target_arch}"/objdump
echo '#!/bin/bash' > "$HOME/cmake-${target_arch}"/ranlib
echo "$target_host-ranlib \"\$@\"" >> "$HOME/cmake-${target_arch}"/ranlib
chmod +x "$HOME/cmake-${target_arch}"/ar
chmod +x "$HOME/cmake-${target_arch}"/as
chmod +x "$HOME/cmake-${target_arch}"/cc
chmod +x "$HOME/cmake-${target_arch}"/c++
chmod +x "$HOME/cmake-${target_arch}"/ld
chmod +x "$HOME/cmake-${target_arch}"/strip
chmod +x "$HOME/cmake-${target_arch}"/nm
chmod +x "$HOME/cmake-${target_arch}"/objcopy
chmod +x "$HOME/cmake-${target_arch}"/objdump
chmod +x "$HOME/cmake-${target_arch}"/ranlib
export PATH="$HOME/bionic-toolchain-${target_arch}/bin"${PATH:+:${PATH}}
export PATH="$HOME/cmake-${target_arch}"${PATH:+:${PATH}}

# pkg-config ### https://autotools.io/pkgconfig/cross-compiling.html
target_sysroot="$HOME/bionic-toolchain-$target_arch/sysroot"
export PKG_CONFIG_PATH=
export PKG_CONFIG_LIBDIR=${target_sysroot}/usr/lib/pkgconfig:${target_sysroot}/usr/share/pkgconfig
export PKG_CONFIG_SYSROOT_DIR=${target_sysroot}

cd build
cmake .. -DCMAKE_BUILD_TYPE="Release" -DCMAKE_INSTALL_PREFIX="$HOME/bionic-toolchain-$target_arch/sysroot/usr" -DCMAKE_C_FLAGS="-fPIE -fPIC -U__ANDROID__ -UANDROID -D__BIONIC__=1" -DCMAKE_CXX_FLAGS="-fPIE -fPIC -U__ANDROID__ -UANDROID -D__BIONIC__=1" -DCMAKE_EXE_LINKER_FLAGS="-pie -Wl,--enable-new-dtags -Wl,-rpath,/XXXXXX -Wl,--no-undefined -L$HOME/bionic-toolchain-${target_arch}/${target_host}/lib -lc++_shared" -DCMAKE_MODULE_LINKER_FLAGS="-Wl,--enable-new-dtags -Wl,-rpath,/XXXXXX -Wl,--no-undefined -L$HOME/bionic-toolchain-${target_arch}/${target_host}/lib -lc++_shared" -DCMAKE_SHARED_LINKER_FLAGS="-Wl,--enable-new-dtags -Wl,-rpath,/XXXXXX -Wl,--no-undefined -L$HOME/bionic-toolchain-${target_arch}/${target_host}/lib -lc++_shared" -DCMAKE_SKIP_INSTALL_RPATH=ON 

cmake-gui

```  
  
## chrpath  /XXXXXX -> \$ORIGIN
```
target_arch=x86_64 ##x86 ##arm64 ##arm

chrpath -r "\$ORIGIN" "$HOME/bionic-toolchain-$target_arch/sysroot/usr/lib/lib***.so"
```  

## some portable problems


> 1\. In bionic the "pw_dir" from "getpwnam(_r) or getpwuid(_r)" is unreliable, use "getenv("HOME")" instead.  

# vk-demos-cube  
![](/ThirdParty/PosixLinuxX11/vk-demos-cube.png)  
