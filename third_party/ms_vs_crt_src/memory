// memory standard header
#pragma once
#ifndef _MEMORY_
#define _MEMORY_
#ifndef RC_INVOKED
#include <xmemory>

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,3)

 #pragma push_macro("new")
 #undef new

 #pragma warning(disable: 4700)

_STD_BEGIN
		// TEMPLATE FUNCTION get_temporary_buffer
template<class _Ty> inline
	pair<_Ty _FARQ *, _PDFT>

		get_temporary_buffer(_PDFT _Count)

	{	// get raw temporary buffer of up to _Count elements
	_Ty _FARQ *_Pbuf;

	if (_Count < 0)
		_Count = 0;
	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count))
		_THROW_NCEE(bad_alloc, 0);
	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty _FARQ *)operator new(
			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));
	}

		// TEMPLATE FUNCTION return_temporary_buffer
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{	// delete raw temporary buffer
	operator delete(_Pbuf);
	}

		// TEMPLATE FUNCTION uninitialized_copy_n
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, input_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input
	_FwdIt _Next = _Dest;

	_TRY_BEGIN
	_Construct(&*_Dest, *_First);	// 0 < _Count has been guaranteed
	while (0 < --_Count)
		_Construct(&*++_Dest, *++_First);
	_CATCH_ALL
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	_RERAISE;
	_CATCH_END
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, forward_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), forward input
	_FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	_CATCH_ALL
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	_RERAISE;
	_CATCH_END
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary iterators
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), pointers to scalars
	_CSTD memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...)
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Rechecked(_Dest,
			_Uninitialized_copy_n(_First, _Count,
				_Unchecked(_Dest))));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n2(_InIt _First, _Diff _Count,
		_FwdIt _Dest, output_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary dest
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n2(_InIt _First, _Diff _Count,
		_FwdIt _Dest, random_access_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access dest
	_FwdIt _Ans = _Dest + _Count;	// also checks range
	_Uninitialized_copy_n(_First, _Count,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, input_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input
	return (_Uninitialized_copy_n2(_First, _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, random_access_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access input
	_InIt _Last = _First + _Count;	// also checks range
	_Last = _Last;	// to quiet diagnostics
	return (_Uninitialized_copy_n2(_Unchecked(_First), _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _STD tr1::true_type)
	{	// copy [_First, _First + _Count) to [_Dest, ...), checked dest
	return (_Uninitialized_copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
_SCL_INSECURE_DEPRECATE
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _STD tr1::false_type)
	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked dest
	return (_Uninitialized_copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...)
	_DEBUG_POINTER(_First);
	_DEBUG_POINTER(_Dest);
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Uninitialized_copy_n(_First,
			_Count, _Dest, _Is_checked(_Dest)));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), array input
	return (_STD uninitialized_copy_n(_Array_iterator<_InTy, _InSize>(_First),
		_Count, _Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
	return (_Unchecked(
		_STD uninitialized_copy_n(_First,
			_Count, _Array_iterator<_OutTy, _OutSize>(_Dest))));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array input/dest
	return (_Unchecked(
		_STD uninitialized_copy_n(_Array_iterator<_InTy, _InSize>(_First),
			_Count, _Array_iterator<_OutTy, _OutSize>(_Dest))));
	}

 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION uninitialized_copy
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw [_Dest, ...), arbitrary iterators
	_FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; _First != _Last; ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	_CATCH_ALL
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	_RERAISE;
	_CATCH_END
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw [_Dest, ...), pointers to scalars
	ptrdiff_t _Count = _Last - _First;
	_CSTD memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	// copy [_First, _Last) to raw [_Dest, ...)
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	// copy [_First, _Last) to raw [_Dest, ...)
	return (_Rechecked(_Dest,
		_Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, input_iterator_tag, forward_iterator_tag)
	{	// copy [_First, _Last) to raw [_Dest, ...), arbitrary iterators
	return (_Uninitialized_copy0(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	// copy [_First, _Last) to raw [_Dest, ...), random-access iterators
	_FwdIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Uninitialized_copy0(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _STD tr1::true_type)
	{	// copy [_First, _Last) to raw [_Dest, ...), checked dest
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
_SCL_INSECURE_DEPRECATE
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _STD tr1::false_type)
	{	// copy [_First, _Last) to raw [_Dest, ...), unchecked dest
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	// copy [_First, _Last) to raw [_Dest, ...)
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _Last) to raw [_Dest, ...)
	return (_Unchecked(
		_STD uninitialized_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION _Uninitialized_copy WITH ALLOCATOR
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	_FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; _First != _Last; ++_Dest, ++_First)
		_Cons_val(_Al, _Dest, *_First);
	_CATCH_ALL
	for (; _Next != _Dest; ++_Next)
		_Dest_val(_Al, _Next);
	_RERAISE;
	_CATCH_END
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw _Dest, using _Al, scalar type
	return (_Uninit_copy(_First, _Last, _Dest,
		_Al, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2> inline
	_Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		allocator<_Ty2>&, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw _Dest, scalar type
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	// copy [_First, _Last) to raw _Dest, using _Al
	return (_Uninit_copy(_First, _Last, _Dest, _Al,
		_Ptr_cat(_First, _Dest)));
	}

		// TEMPLATE FUNCTION _Uninitialized_move WITH ALLOCATOR
template<class _InIt,
	class _FwdIt,
	class _Alloc,
	class _Valty> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	_FwdIt _Next = _Dest;

	_TRY_BEGIN
	for (; _First != _Last; ++_Dest, ++_First)
		_Cons_val(_Al, _Dest, (_Valty &&)*_First);
	_CATCH_ALL
	for (; _Next != _Dest; ++_Next)
		_Dest_val(_Al, _Next);
	_RERAISE;
	_CATCH_END
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc,
	class _Valty> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Valty *, _Scalar_ptr_iterator_tag)
	{	// move [_First, _Last) to raw _Dest, using _Al, scalar type
	return (_Uninit_move(_First, _Last, _Dest,
		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2,
	class _Valty> inline
	_Ty2 *_Uninit_move(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		allocator<_Ty2>&, _Valty *, _Scalar_ptr_iterator_tag)
	{	// move [_First, _Last) to raw _Dest, scalar type
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	// move [_First, _Last) to raw _Dest, using _Al
	return (_Uninit_move(_First, _Last, _Dest, _Al,
		_Val_type(_First), _Ptr_cat(_First, _Dest)));
	}

		// TEMPLATE FUNCTION uninitialized_fill
template<class _FwdIt,
	class _Tval> inline
	void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	// copy _Val throughout raw [_First, _Last), arbitrary type
	_DEBUG_RANGE(_First, _Last);
	_FwdIt _Next = _First;

	_TRY_BEGIN
	for (; _First != _Last; ++_First)
		_Construct(&*_First, _Val);
	_CATCH_ALL
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	_RERAISE;
	_CATCH_END
	}

template<class _Ty,
	class _Tval> inline
	void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	// copy _Val throughout raw [_First, _Last), scalar type
	_STD fill(_First, _Last, _Val);
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	// copy _Val throughout raw [_First, _Last)
	_Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
	}

		// TEMPLATE FUNCTION uninitialized_fill_n
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	// copy _Count *_Val to raw _First, arbitrary type
 #if _ITERATOR_DEBUG_LEVEL == 2
//	if (_Count < 0)
//		_DEBUG_ERROR("negative count in uninitialized fill");
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

	_FwdIt _Next = _First;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, ++_First)
		_Construct(&*_First, _Val);
	_CATCH_ALL
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	_RERAISE;
	_CATCH_END
	}

template<class _Ty,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	// copy _Count *_Val to raw _First, scalar type
	_STD _Fill_n(_First, _Count, _Val);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	// copy _Count *_Val to raw _First
	_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First));
	}

		// TEMPLATE FUNCTION _Uninitialized_fill_n WITH ALLOCATOR
template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Alloc& _Al,
			_Valty *, _Nonscalar_ptr_iterator_tag)
	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type
 #if _ITERATOR_DEBUG_LEVEL == 2
//	if (_Count < 0)
//		_DEBUG_ERROR("negative count in uninitialized fill");
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

	_FwdIt _Next = _First;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, ++_First)
		_Cons_val(_Al, _First, *_Pval);
	_CATCH_ALL
	for (; _Next != _First; ++_Next)
		_Dest_val(_Al, _Next);
	_RERAISE;
	_CATCH_END
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Alloc& _Al,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type
	_Uninit_fill_n(_First, _Count,
		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
	}

template<class _Ty,
	class _Diff,
	class _Tval,
	class _Valty> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count,
		const _Tval *_Pval, allocator<_Ty>&,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	// copy _Count * *_Pval to raw _First, using _Al, scalar type
	_Fill_n(_First, _Count, *_Pval);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Alloc& _Al)
	{	// copy _Count * *_Pval to raw _First, using _Al
	_Uninit_fill_n(_First, _Count, _Pval, _Al,
		_Val_type(_First), _Ptr_cat(_First, _First));
	}

		// TEMPLATE FUNCTION _Uninitialized_default_fill_n WITH ALLOCATOR
template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *, _Alloc& _Al,
			_Valty *, _Nonscalar_ptr_iterator_tag)
	{	// copy _Count * _Valty() to raw _First, using _Al, arbitrary type
 #if _ITERATOR_DEBUG_LEVEL == 2
//	if (_Count < 0)
//		_DEBUG_ERROR("negative count in uninitialized fill");
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

	_FwdIt _Next = _First;

	_TRY_BEGIN
	for (; 0 < _Count; --_Count, ++_First)

		_Cons_val(_Al, _First, _Valty());

	_CATCH_ALL
	for (; _Next != _First; ++_Next)
		_Dest_val(_Al, _Next);
	_RERAISE;
	_CATCH_END
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Alloc& _Al,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	// copy _Count * _Valty() to raw _First, using _Al, arbitrary type
	_Uninit_def_fill_n(_First, _Count,
		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
	}

template<class _Ty,
	class _Diff,
	class _Tval,
	class _Valty> inline
	void _Uninit_def_fill_n(_Ty *_First, _Diff _Count,
		const _Tval *, allocator<_Ty>&,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type
	_Fill_n(_First, _Count, (_Valty)0);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Alloc& _Al)
	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al
	_Uninit_def_fill_n(_First, _Count, _Pval, _Al,
		_Val_type(_First), _Ptr_cat(_First, _First));
	}

		// TEMPLATE CLASS raw_storage_iterator
template<class _FwdIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{	// wrap stores to raw buffer as output iterator
public:
	typedef _FwdIt iterator_type;	// retained
	typedef _FwdIt iter_type;	// retained
	typedef _Ty element_type;	// retained

	explicit raw_storage_iterator(_FwdIt _First)
		: _Next(_First)
		{	// construct with iterator
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator=(const _Ty& _Val)
		{	// construct value designated by stored iterator
		_Construct(&*_Next, _Val);
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator++()
		{	// preincrement
		++_Next;
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty> operator++(int)
		{	// postincrement
		raw_storage_iterator<_FwdIt, _Ty> _Ans = *this;
		++_Next;
		return (_Ans);
		}

private:
	_FwdIt _Next;	// the stored iterator
	};

		// TEMPLATE CLASS _Temp_iterator
template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{	// wrap stores to temporary buffer as output iterator
public:
	typedef _Ty _FARQ *_Pty;

	_Temp_iterator(_PDFT _Count = 0)
		{	// construct from desired temporary buffer size
		_Buf._Begin = 0;
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = _Count;	// memorize size for lazy allocation
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)
		{	// construct from _Right (share active buffer)
		_Buf._Begin = 0;	// clear stored buffer, for safe destruction
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator()
		{	// destroy the object
		if (_Buf._Begin != 0)
			{	// destroy any constructed elements in buffer
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(&*_Next);
			_STD return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
		{	// assign _Right (share active buffer)
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(const _Ty& _Val)
		{	// assign or construct value into active buffer, and increment
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;	// below high water mark, assign
		else
			{	// above high water mark, construct
			_Pty _Ptr = &*_Pbuf->_Current;
			_Construct(_Ptr, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(_Ty&& _Val)
		{	// move or construct value into active buffer, and increment
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ =
				_STD forward<_Ty>(_Val);	// below high water mark, move
		else
			{	// above high water mark, construct
			_Pty _Ptr = &*_Pbuf->_Current;
			_Construct(_Ptr, _STD forward<_Ty>(_Val));
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

	_Temp_iterator<_Ty>& _Init()
		{	// set pointer at beginning of buffer
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{	// return pointer to beginning of buffer
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{	// return pointer past end of buffer contents
		return (_Pbuf->_Current);
		}

	_PDFT _Maxlen()
		{	// return size of buffer
		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
			{	// allocate buffer on first size query
			pair<_Pty, _PDFT> _Pair =

				_STD get_temporary_buffer<_Ty>(_Pbuf->_Size);

			_Pbuf->_Begin = _Pair.first;
			_Pbuf->_Current = _Pair.first;
			_Pbuf->_Hiwater = _Pair.first;
			_Pbuf->_Size = _Pair.second;
			}
		return (_Pbuf->_Size);
		}

private:
	struct _Bufpar
		{	// control information for a temporary buffer
		_Pty _Begin;	// pointer to beginning of buffer
		_Pty _Current;	// pointer to next available element
		_Pty _Hiwater;	// pointer to first unconstructed element
		_PDFT _Size;	// length of buffer
		};
	_Bufpar _Buf;	// buffer control stored in iterator
	_Bufpar *_Pbuf;	// pointer to active buffer control
	};

		// TEMPLATE CLASS auto_ptr
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	// proxy reference for auto_ptr copying
	explicit auto_ptr_ref(_Ty *_Right)
		: _Ref(_Right)
		{	// construct from generic pointer to auto_ptr ptr
		}

	_Ty *_Ref;	// generic pointer to auto_ptr ptr
	};

template<class _Ty>
	class auto_ptr
		{	// wrap an object pointer to ensure destruction
public:
	typedef auto_ptr<_Ty> _Myt;
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) _THROW0()
		: _Myptr(_Ptr)
		{	// construct from object pointer
		}

	auto_ptr(_Myt& _Right) _THROW0()
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right auto_ptr
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()
		{	// construct by assuming pointer from _Right auto_ptr_ref
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	// release old
		_Myptr = _Ptr;	// reset this
		}

	template<class _Other>
		operator auto_ptr<_Other>() _THROW0()
		{	// convert to compatible auto_ptr
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() _THROW0()
		{	// convert to compatible auto_ptr_ref
		_Other *_Cvtptr = _Myptr;	// test implicit conversion
		auto_ptr_ref<_Other> _Ans(_Cvtptr);
		_Myptr = 0;	// pass ownership to auto_ptr_ref
		return (_Ans);
		}

	template<class _Other>
		_Myt& operator=(auto_ptr<_Other>& _Right) _THROW0()
		{	// assign compatible _Right (assume pointer)
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) _THROW0()
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right
		}

	_Myt& operator=(_Myt& _Right) _THROW0()
		{	// assign compatible _Right (assume pointer)
		reset(_Right.release());
		return (*this);
		}

	_Myt& operator=(auto_ptr_ref<_Ty> _Right) _THROW0()
		{	// assign compatible _Right._Ref (assume pointer)
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	// release old
		reset(_Ptr);	// set new
		return (*this);
		}

	~auto_ptr()
		{	// destroy the object
		delete _Myptr;
		}

	_Ty& operator*() const _THROW0()
		{	// return designated value
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Myptr == 0)
			_DEBUG_ERROR("auto_ptr not dereferencable");
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

		return (*get());
		}

	_Ty *operator->() const _THROW0()
		{	// return pointer to class object
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Myptr == 0)
			_DEBUG_ERROR("auto_ptr not dereferencable");
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

		return (get());
		}

	_Ty *get() const _THROW0()
		{	// return wrapped pointer
		return (_Myptr);
		}

	_Ty *release() _THROW0()
		{	// return wrapped pointer and give up ownership
		_Ty *_Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty *_Ptr = 0)
		{	// destroy designated object and store new pointer
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty *_Myptr;	// the wrapped object pointer
	};
_STD_END

 #if _HAS_TR1
 #ifndef _XSTD2
  #define _XSTD2
 #endif /* _XSTD2 */

 #include <exception>
 #include <typeinfo>
 #include <type_traits>

 #include <intrin.h>

  #define _MT_INCR(mtx, x)	_InterlockedIncrement(&x)
  #define _MT_DECR(mtx, x)	_InterlockedDecrement(&x)
  #define _MT_CMPX(x, y, z)	_InterlockedCompareExchange(&x, y, z)

_STD_BEGIN
 #if _HAS_CPP0X
template<class _Ty>
	struct default_delete;

template<class _Ty,
	class _Dx = default_delete<_Ty> >
	class unique_ptr;
 #endif /* _HAS_CPP0X */

	namespace tr1 {	// TR1 additions
	// CLASS bad_weak_ptr
class bad_weak_ptr
	: public exception
	{	// exception type for invalid use of expired weak_ptr object
public:
	explicit bad_weak_ptr(const char * = 0)
		{	// construct with ignored message
		}

	virtual const char *__CLR_OR_THIS_CALL what() const throw()
		{	// return pointer to message string
		return ("tr1::bad_weak_ptr");
		}
	};

	// CLASS _Ref_count_base
class _Ref_count_base
	{	// common code for reference counting
private:
	virtual void _Destroy() = 0;
	virtual void _Delete_this() = 0;

	long _Uses;
	long _Weaks;

protected:
	_Ref_count_base()
		: _Uses(1), _Weaks(1)
		{	// construct
		}

public:
	virtual ~_Ref_count_base()
		{	// ensure that derived classes can be destroyed properly
		}

	bool _Incref_nz()
		{	// increment use count if not zero, return true if successful
		for (; ; )
			{	// loop until state is known
			long _Count = (volatile long&)_Uses;
			if (_Count == 0)
				return (false);
			if (_MT_CMPX(_Uses, _Count + 1, _Count) == _Count)
				return (true);
			}
		}

	void _Incref()
		{	// increment use count
		_MT_INCR(_Mtx, _Uses);
		}

	void _Incwref()
		{	// increment weak reference count
		_MT_INCR(_Mtx, _Weaks);
		}

	void _Decref()
		{	// decrement use count
		if (_MT_DECR(_Mtx, _Uses) == 0)
			{	// destroy managed resource, decrement weak reference count
			_Destroy();
			_Decwref();
			}
		}

	void _Decwref()
		{	// decrement weak reference count
		if (_MT_DECR(_Mtx, _Weaks) == 0)
			_Delete_this();
		}

	long _Use_count() const
		{	// return use count
		return (_Uses);
		}

	bool _Expired() const
		{	// return true if _Uses == 0
		return (_Uses == 0);
		}

	virtual void *_Get_deleter(const _XSTD2 type_info&) const
		{	// return address of deleter object
		return (0);
		}
	};

	// TEMPLATE CLASS _Ref_count, _Ref_count_del, _Ref_count_del_alloc
template<class _Ty>
	class _Ref_count
	: public _Ref_count_base
	{	// handle reference counting for object without deleter
public:
	_Ref_count(_Ty *_Px)
		: _Ref_count_base(), _Ptr(_Px)
		{	// construct
		}

private:
	virtual void _Destroy()
		{	// destroy managed resource
		delete _Ptr;
		}

	virtual void _Delete_this()
		{	// destroy self
		delete this;
		}

	_Ty * _Ptr;
	};

template<class _Ty,
	class _Dx>
	class _Ref_count_del
	: public _Ref_count_base
	{	// handle reference counting for object with deleter
public:
	_Ref_count_del(_Ty *_Px, _Dx _Dt)
		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
		{	// construct
		}

	virtual void *_Get_deleter(const _XSTD2 type_info& _Type) const
		{	// return address of deleter object
		return ((void *)(_Type == typeid(_Dx) ? &_Dtor : 0));
		}

private:
	virtual void _Destroy()
		{	// destroy managed resource
		_Dtor(_Ptr);
		}

	virtual void _Delete_this()
		{	// destroy self
		delete this;
		}

	_Ty * _Ptr;
	_Dx _Dtor;	// the stored destructor for the controlled object
	};

template<class _Ty,
	class _Dx,
	class _Alloc>
	class _Ref_count_del_alloc
	: public _Ref_count_base
	{	// handle reference counting for object with deleter and allocator
public:
	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;

	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
		{	// construct
		}

	virtual void *_Get_deleter(const _XSTD2 type_info& _Type) const
		{	// return address of deleter object
		return ((void *)(_Type == typeid(_Dx) ? &_Dtor : 0));
		}

private:
	virtual void _Destroy()
		{	// destroy managed resource
		_Dtor(_Ptr);
		}

	virtual void _Delete_this()
		{	// destroy self
		_Myalty _Al = _Myal;
		_Dest_val(_Al, this);
		_Al.deallocate(this, 1);
		}

	_Ty * _Ptr;
	_Dx _Dtor;	// the stored destructor for the controlled object
	_Myalty _Myal;	// the stored allocator for this
	};

	// DECLARATIONS
template<class _Ty>
	class weak_ptr;
template<class _Ty>
	class shared_ptr;
template<class _Ty>
	class enable_shared_from_this;
struct _Static_tag {};
struct _Const_tag {};
struct _Dynamic_tag {};
template<class _Ty1,
	class _Ty2>
	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
		_Ref_count_base *);

template<class _Ty>
	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
		typename _Ty::_EStype * = 0)
	{	// reset internal weak pointer
	if (_Ptr)
		_Do_enable(_Ptr,
			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
	}

inline void _Enable_shared(const volatile void *, const volatile void *)
	{	// not derived from enable_shared_from_this; do nothing
	}

	// TEMPLATE CLASS _Ptr_base
template<class _Ty>
	class _Ptr_base
	{	// base class for shared_ptr and weak_ptr
public:
	typedef _Ptr_base<_Ty> _Myt;
	typedef _Ty _Elem;
	typedef _Elem element_type;

	_Ptr_base()
		: _Ptr(0), _Rep(0)
		{	// construct
		}

	_Ptr_base(_Myt&& _Right)
		: _Ptr(0), _Rep(0)
		{	// construct _Ptr_base object that takes resource from _Right
		_Assign_rv(_STD forward<_Myt>(_Right));
		}

	template<class _Ty2>
		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
		{	// construct _Ptr_base object that takes resource from _Right
		_Right._Ptr = 0;
		_Right._Rep = 0;
		}

	_Myt& operator=(_Myt&& _Right)
		{	// construct _Ptr_base object that takes resource from _Right
		_Assign_rv(_STD forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	// assign by moving _Right
		if (this != &_Right)
			_Swap(_Right);
		}

	long use_count() const
		{	// return use count
		return (_Rep ? _Rep->_Use_count() : 0);
		}

	void _Swap(_Ptr_base& _Right)
		{	// swap pointers
		_STD swap(_Rep, _Right._Rep);
		_STD swap(_Ptr, _Right._Ptr);
		}

	template<class _Ty2>
		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
		{	// compare addresses of manager objects
		return (_Rep < _Right._Rep);
		}

	void *_Get_deleter(const _XSTD2 type_info& _Type) const
		{	// return pointer to deleter object if its type is _Type
		return (_Rep ? _Rep->_Get_deleter(_Type) : 0);
		}

	_Ty *_Get() const
		{	// return pointer to resource
		return (_Ptr);
		}

	bool _Expired() const
		{	// test if expired
		return (!_Rep || _Rep->_Expired());
		}

	void _Decref()
		{	// decrement reference count
		if (_Rep != 0)
			_Rep->_Decref();
		}

	void _Reset()
		{	// release resource
		_Reset(0, 0);
		}

	template<class _Ty2>
		void _Reset(const _Ptr_base<_Ty2>& _Other)
		{	// release resource and take ownership of _Other._Ptr
		_Reset(_Other._Ptr, _Other._Rep, false);
		}

	template<class _Ty2>
		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
		{	// release resource and take ownership from weak_ptr _Other._Ptr
		_Reset(_Other._Ptr, _Other._Rep, _Throw);
		}

	template<class _Ty2>
		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
		{	// release resource and take ownership of _Other._Ptr
		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
		}

	template<class _Ty2>
		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
		{	// release resource and take ownership of _Other._Ptr
		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
		}

	template<class _Ty2>
		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
		{	// release resource and take ownership of _Other._Ptr
		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
		if (_Ptr)
			_Reset(_Ptr, _Other._Rep);
		else
			_Reset();
		}

	template<class _Ty2>
		void _Reset(auto_ptr<_Ty2>& _Other)
		{	// release resource and take _Other.get()
		_Ty2 *_Px = _Other.get();
		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
		_Other.release();
		_Enable_shared(_Px, _Rep);
		}

 #if _HAS_CPP0X
	template<class _Ty2>
		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
		{	// release resource and alias _Ptr with _Other_rep
		_Reset(_Ptr, _Other._Rep);
		}
 #endif /* _HAS_CPP0X */

	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
		{	// release resource and take _Other_ptr through _Other_rep
		if (_Other_rep)
			_Other_rep->_Incref();
		_Reset0(_Other_ptr, _Other_rep);
		}

	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
			// otherwise, leave in default state if !_Throw,
			// otherwise throw exception
		if (_Other_rep && _Other_rep->_Incref_nz())
			_Reset0(_Other_ptr, _Other_rep);
		else if (_Throw)
			_THROW_NCEE(bad_weak_ptr, 0);
		}

	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
		{	// release resource and take new resource
		if (_Rep != 0)
			_Rep->_Decref();
		_Rep = _Other_rep;
		_Ptr = _Other_ptr;
		}

	void _Decwref()
		{	// decrement weak reference count
		if (_Rep != 0)
			_Rep->_Decwref();
		}

	void _Resetw()
		{	// release weak reference to resource
		_Resetw((_Elem *)0, 0);
		}

	template<class _Ty2>
		void _Resetw(const _Ptr_base<_Ty2>& _Other)
		{	// release weak reference to resource and take _Other._Ptr
		_Resetw(_Other._Ptr, _Other._Rep);
		}

	template<class _Ty2>
		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
		{	// point to _Other_ptr through _Other_rep
		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
		}

	template<class _Ty2>
		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
		{	// point to _Other_ptr through _Other_rep
		if (_Other_rep)
			_Other_rep->_Incwref();
		if (_Rep != 0)
			_Rep->_Decwref();
		_Rep = _Other_rep;
		_Ptr = _Other_ptr;
		}

private:
	_Ty *_Ptr;
	_Ref_count_base *_Rep;
	template<class _Ty0>
		friend class _Ptr_base;
	};

	// TEMPLATE CLASS shared_ptr
template<class _Ty>
	class shared_ptr
		: public _Ptr_base<_Ty>
	{	// class for reference counted resource management
public:
	typedef shared_ptr<_Ty> _Myt;
	typedef _Ptr_base<_Ty> _Mybase;

	shared_ptr()
		{	// construct empty shared_ptr object
		}

	template<class _Ux>
		explicit shared_ptr(_Ux *_Px)
		{	// construct shared_ptr object that owns _Px
		_Resetp(_Px);
		}

	template<class _Ux,
		class _Dx>
		shared_ptr(_Ux *_Px, _Dx _Dt)
		{	// construct with _Px, deleter
		_Resetp(_Px, _Dt);
		}

//#if _HAS_CPP0X

 #if defined(_NATIVE_NULLPTR_SUPPORTED) \
	&& !defined(_DO_NOT_USE_NULLPTR_IN_STL)

	shared_ptr(_STD nullptr_t)
		{	// construct with nullptr
		_Resetp((_Ty *)0);
		}

	template<class _Dx>
		shared_ptr(_STD nullptr_t, _Dx _Dt)
		{	// construct with nullptr, deleter
		_Resetp((_Ty *)0, _Dt);
		}

	template<class _Dx,
		class _Alloc>
		shared_ptr(_STD nullptr_t, _Dx _Dt, _Alloc _Ax)
		{	// construct with nullptr, deleter, allocator
		_Resetp((_Ty *)0, _Dt, _Ax);
		}
 #endif /* defined(_NATIVE_NULLPTR_SUPPORTED) etc. */

	template<class _Ux,
		class _Dx,
		class _Alloc>
		shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
		{	// construct with _Px, deleter, allocator
		_Resetp(_Px, _Dt, _Ax);
		}
//#endif /* _HAS_CPP0X */

 #if _HAS_CPP0X
	template<class _Ty2>
		shared_ptr(const shared_ptr<_Ty2>& _Right, _Ty *_Px)
		{	// construct shared_ptr object that aliases _Right
		this->_Reset(_Px, _Right);
		}
 #endif /* _HAS_CPP0X */

	shared_ptr(const _Myt& _Other)
		{	// construct shared_ptr object that owns same resource as _Other
		this->_Reset(_Other);
		}

	template<class _Ty2>
		shared_ptr(const shared_ptr<_Ty2>& _Other,
			typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
				void *>::type * = 0)
		{	// construct shared_ptr object that owns same resource as _Other
		this->_Reset(_Other);
		}

	template<class _Ty2>
		explicit shared_ptr(const weak_ptr<_Ty2>& _Other,
			bool _Throw = true)
		{	// construct shared_ptr object that owns resource *_Other
		this->_Reset(_Other, _Throw);
		}

	template<class _Ty2>
		shared_ptr(auto_ptr<_Ty2>& _Other)
		{	// construct shared_ptr object that owns *_Other.get()
		this->_Reset(_Other);
		}

	template<class _Ty2>
		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Static_tag& _Tag)
		{	// construct shared_ptr object for static_pointer_cast
		this->_Reset(_Other, _Tag);
		}

	template<class _Ty2>
		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Const_tag& _Tag)
		{	// construct shared_ptr object for const_pointer_cast
		this->_Reset(_Other, _Tag);
		}

	template<class _Ty2>
		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Dynamic_tag& _Tag)
		{	// construct shared_ptr object for dynamic_pointer_cast
		this->_Reset(_Other, _Tag);
		}

	shared_ptr(_Myt&& _Right)
		: _Mybase(_STD forward<_Myt>(_Right))
		{	// construct shared_ptr object that takes resource from _Right
		}

	template<class _Ty2>
		shared_ptr(shared_ptr<_Ty2>&& _Right,
			typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
				void *>::type * = 0)
		: _Mybase(_STD forward<shared_ptr<_Ty2> >(_Right))
		{	// construct shared_ptr object that takes resource from _Right
		}

 #if _HAS_CPP0X
	template<class _Ux,
		class _Dx>
		shared_ptr(_STD unique_ptr<_Ux, _Dx>&& _Right)
		{	// construct from unique_ptr
		_Resetp(_Right.release(), _Right.get_deleter());
		}

	template<class _Ux,
		class _Dx>
		_Myt& operator=(unique_ptr<_Ux, _Dx>&& _Right)
		{	// move from unique_ptr
		shared_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}
 #endif /* _HAS_CPP0X */

	_Myt& operator=(_Myt&& _Right)
		{	// construct shared_ptr object that takes resource from _Right
		shared_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		_Myt& operator=(shared_ptr<_Ty2>&& _Right)
		{	// construct shared_ptr object that takes resource from _Right
		shared_ptr(_STD move(_Right)).swap(*this);
		return (*this);
		}

	void swap(_Myt&& _Right)
		{	// exchange contents with movable _Right
		_Mybase::swap(_STD move(_Right));
		}

	~shared_ptr()
		{	// release resource
		this->_Decref();
		}

	_Myt& operator=(const _Myt& _Right)
		{	// assign shared ownership of resource owned by _Right
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		_Myt& operator=(const shared_ptr<_Ty2>& _Right)
		{	// assign shared ownership of resource owned by _Right
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		_Myt& operator=(auto_ptr<_Ty2>& _Right)
		{	// assign ownership of resource pointed to by _Right
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

	void reset()
		{	// release resource and convert to empty shared_ptr object
		shared_ptr().swap(*this);
		}

	template<class _Ux>
		void reset(_Ux *_Px)
		{	// release, take ownership of _Px
		shared_ptr(_Px).swap(*this);
		}

	template<class _Ux,
		class _Dx>
		void reset(_Ux *_Px, _Dx _Dt)
		{	// release, take ownership of _Px, with deleter _Dt
		shared_ptr(_Px, _Dt).swap(*this);
		}

//#if _HAS_CPP0X
	template<class _Ux,
		class _Dx,
		class _Alloc>
		void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
		{	// release, take ownership of _Px, with deleter _Dt, allocator _Ax
		shared_ptr(_Px, _Dt, _Ax).swap(*this);
		}
//#endif /* _HAS_CPP0X */

	void swap(_Myt& _Other)
		{	// swap pointers
		this->_Swap(_Other);
		}

	_Ty *get() const
		{	// return pointer to resource
		return (this->_Get());
		}

	typename tr1::add_reference<_Ty>::type operator*() const
		{	// return reference to resource
		return (*this->_Get());
		}

	_Ty *operator->() const
		{	// return pointer to resource
		return (this->_Get());
		}

	bool unique() const
		{	// return true if no other shared_ptr object owns this resource
		return (this->use_count() == 1);
		}

	_OPERATOR_BOOL() const
		{	// test if shared_ptr object owns no resource
		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
		}

private:
	template<class _Ux>
		void _Resetp(_Ux *_Px)
		{	// release, take ownership of _Px
		_TRY_BEGIN	// allocate control block and reset
		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));
		_CATCH_ALL	// allocation failed, delete resource
		delete _Px;
		_RERAISE;
		_CATCH_END
		}

	template<class _Ux,
		class _Dx>
		void _Resetp(_Ux *_Px, _Dx _Dt)
		{	// release, take ownership of _Px, deleter _Dt
		_TRY_BEGIN	// allocate control block and reset
		_Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
		_CATCH_ALL	// allocation failed, delete resource
		_Dt(_Px);
		_RERAISE;
		_CATCH_END
		}

//#if _HAS_CPP0X
	template<class _Ux,
		class _Dx,
		class _Alloc>
		void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
		{	// release, take ownership of _Px, deleter _Dt, allocator _Ax
		typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
		typename _Alloc::template rebind<_Refd>::other _Al = _Ax;

		_TRY_BEGIN	// allocate control block and reset
		_Refd *_Ptr = _Al.allocate(1);
		new (_Ptr) _Refd(_Px, _Dt, _Al);
		_Resetp0(_Px, _Ptr);
		_CATCH_ALL	// allocation failed, delete resource
		_Dt(_Px);
		_RERAISE;
		_CATCH_END
		}
//#endif /* _HAS_CPP0X */

public:
	template<class _Ux>
		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
		{	// release resource and take ownership of _Px
		this->_Reset0(_Px, _Rx);
		_Enable_shared(_Px, _Rx);
		}
	};

template<class _Ty1,
	class _Ty2>
	bool operator==(const shared_ptr<_Ty1>& _S1,
		const shared_ptr<_Ty2>& _S2)
	{	// test if shared_ptr == shared_ptr
	return (_S1.get() == _S2.get());
	}

template<class _Ty1,
	class _Ty2>
	bool operator!=(const shared_ptr<_Ty1>& _S1,
		const shared_ptr<_Ty2>& _S2)
	{	// test if shared_ptr != shared_ptr
	return (!(_S1 == _S2));
	}

template<class _Ty1,
	class _Ty2>
	bool operator<(const shared_ptr<_Ty1>& _S1,
		const shared_ptr<_Ty2>& _S2)
	{	// test if shared_ptr < shared_ptr
	return (_S1.get() < _S2.get());
	}

template<class _Ty1,
	class _Ty2>
	bool operator>=(const shared_ptr<_Ty1>& _S1,
		const shared_ptr<_Ty2>& _S2)
	{	// shared_ptr >= shared_ptr
	return (!(_S1 < _S2));
	}

template<class _Ty1,
	class _Ty2>
	bool operator>(const shared_ptr<_Ty1>& _S1,
		const shared_ptr<_Ty2>& _S2)
	{	// test if shared_ptr > shared_ptr
	return (_S2 < _S1);
	}

template<class _Ty1,
	class _Ty2>
	bool operator<=(const shared_ptr<_Ty1>& _S1,
		const shared_ptr<_Ty2>& _S2)
	{	// test if shared_ptr <= shared_ptr
	return (!(_S2 < _S1));
	}

template<class _Elem,
	class _Traits,
	class _Ty>
	basic_ostream<_Elem, _Traits>&
	operator<<(basic_ostream<_Elem, _Traits>& _Out,
		const shared_ptr<_Ty>& _Px)
	{	// write contained pointer to stream
	return (_Out << _Px.get());
	}

template<class _Ty>
	void swap(shared_ptr<_Ty>& _Left,
		shared_ptr<_Ty>& _Right)
	{	// swap _Left and _Right shared_ptrs
	_Left.swap(_Right);
	}

template<class _Ty>
	void swap(shared_ptr<_Ty>& _Left,
		shared_ptr<_Ty>&& _Right)
	{	// swap _Left and _Right shared_ptrs
	_Left.swap(_Right);
	}

template<class _Ty>
	void swap(shared_ptr<_Ty>&& _Left,
		shared_ptr<_Ty>& _Right)
	{	// swap _Left and _Right shared_ptrs
	_Right.swap(_Left);
	}

template<class _Ty1,
	class _Ty2>
	shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other)
	{	// return shared_ptr object holding static_cast<_Ty1 *>(_Other.get())
	return (shared_ptr<_Ty1>(_Other, _Static_tag()));
	}

template<class _Ty1,
	class _Ty2>
	shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other)
	{	// return shared_ptr object holding const_cast<_Ty1 *>(_Other.get())
	return (shared_ptr<_Ty1>(_Other, _Const_tag()));
	}

template<class _Ty1,
	class _Ty2>
	shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other)
	{	// return shared_ptr object holding dynamic_cast<_Ty1 *>(_Other.get())
	return (shared_ptr<_Ty1>(_Other, _Dynamic_tag()));
	}

template<class _Dx,
	class _Ty>
	_Dx *get_deleter(const shared_ptr<_Ty>& _Sx)
	{	// return pointer to shared_ptr's deleter object if its type is _Ty
	return ((_Dx *)_Sx._Get_deleter(typeid(_Dx)));
	}

 #if _HAS_CPP0X

	// TEMPLATE CLASS _Ref_count_obj
template<class _Ty>
	class _Ref_count_obj
	: public _Ref_count_base
	{	// handle reference counting for object in control block, no allocator
public:
 #define _REF_COUNT_OBJ_CTOR
 #define _INCL_FILE_xxshared
 #include <xfwrap>
 #undef _REF_COUNT_OBJ_CTOR

	_Ty *_Getptr() const
		{	// get pointer
		return ((_Ty *)&_Storage);
		}

private:
	virtual void _Destroy()
		{	// destroy managed resource
		_Getptr()->~_Ty();
		}

	virtual void _Delete_this()
		{	// destroy self
		delete this;
		}

	typename aligned_storage<sizeof(_Ty),
		alignment_of<_Ty>::value>::type _Storage;
	};

	// TEMPLATE CLASS _Ref_count_obj_alloc
template<class _Ty,
	class _Alloc>
	class _Ref_count_obj_alloc
	: public _Ref_count_base
	{	// handle reference counting for object in control block, allocator
public:
	typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Myty;
	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;

 #define _REF_COUNT_OBJ_ALLOC_CTOR
 #define _INCL_FILE_xxshared
 #include <xfwrap>
 #undef _REF_COUNT_OBJ_ALLOC_CTOR

	_Ty *_Getptr() const
		{	// get pointer
		return ((_Ty *)&_Storage);
		}

private:
	virtual void _Destroy()
		{	// destroy managed resource
		_Getptr()->~_Ty();
		}

	virtual void _Delete_this()
		{	// destroy self
		_Myalty _Al = _Myal;
		_Dest_val(_Al, this);
		_Al.deallocate(this, 1);
		}

	typename aligned_storage<sizeof (_Ty),
		alignment_of<_Ty>::value>::type _Storage;
	_Myalty _Myal;	// the stored allocator for this
	};

 #define _MAKE_SHARED
 #define _INCL_FILE_xxshared
 #include <xfwrap>
 #undef _MAKE_SHARED

 #endif /* _HAS_CPP0X */

	// TEMPLATE CLASS weak_ptr
template<class _Ty>
	class weak_ptr
		: public _Ptr_base<_Ty>
	{	// class for pointer to reference counted resource
	typedef typename _Ptr_base<_Ty>::_Elem _Elem;

public:
	weak_ptr()
		{	// construct empty weak_ptr object
		}

	template<class _Ty2>
		weak_ptr(const shared_ptr<_Ty2>& _Other,
			typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
				void *>::type * = 0)
		{	// construct weak_ptr object for resource owned by _Other
		this->_Resetw(_Other);
		}

	weak_ptr(const weak_ptr& _Other)
		{	// construct weak_ptr object for resource pointed to by _Other
		this->_Resetw(_Other);
		}

	template<class _Ty2>
		weak_ptr(const weak_ptr<_Ty2>& _Other,
			typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
				void *>::type * = 0)
		{	// construct weak_ptr object for resource pointed to by _Other
		this->_Resetw(_Other);
		}

	~weak_ptr()
		{	// release resource
		this->_Decwref();
		}

	weak_ptr& operator=(const weak_ptr& _Right)
		{	// assign from _Right
		this->_Resetw(_Right);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(const weak_ptr<_Ty2>& _Right)
		{	// assign from _Right
		this->_Resetw(_Right);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(shared_ptr<_Ty2>& _Right)
		{	// assign from _Right
		this->_Resetw(_Right);
		return (*this);
		}

	void reset()
		{	// release resource, convert to null weak_ptr object
		this->_Resetw();
		}

	void swap(weak_ptr& _Other)
		{	// swap pointers
		this->_Swap(_Other);
		}

	bool expired() const
		{	// return true if resource no longer exists
		return (this->_Expired());
		}

	shared_ptr<_Ty> lock() const
		{	// convert to shared_ptr
		return (shared_ptr<_Elem>(*this, false));
		}
	};

//template<class _Ty1,
//	class _Ty2>
//	bool operator<(const weak_ptr<_Ty1>& _W1,
//		const weak_ptr<_Ty2>& _W2)
//	{	// return true if _S1 precedes _S2 (order defined by control block)
//	return (_W1.owner_before(_W2));
//	}

template<class _Ty>
	void swap(weak_ptr<_Ty>& _W1, weak_ptr<_Ty>& _W2)
	{	// swap contents of _W1 and _W2
	_W1.swap(_W2);
	}

	// TEMPLATE CLASS enable_shared_from_this
template<class _Ty> class enable_shared_from_this
	{	// provide member functions that create shared_ptr to this
public:
	typedef _Ty _EStype;

	shared_ptr<_Ty> shared_from_this()
		{	// return shared_ptr
		return (shared_ptr<_Ty>(_Wptr));
		}

	shared_ptr<const _Ty> shared_from_this() const
		{	// return shared_ptr
		return (shared_ptr<const _Ty>(_Wptr));
		}

protected:
	enable_shared_from_this()
		{	// construct (do nothing)
		}

	enable_shared_from_this(const enable_shared_from_this&)
		{	// construct (do nothing)
		}

	enable_shared_from_this& operator=(const enable_shared_from_this&)
		{	// assign (do nothing)
		return (*this);
		}

	~enable_shared_from_this()
		{	// destroy (do nothing)
		}

private:
	template<class _Ty1,
		class _Ty2>
		friend void _Do_enable(
			_Ty1 *,
			enable_shared_from_this<_Ty2>*,
			_Ref_count_base *);

	mutable weak_ptr<_Ty> _Wptr;
	};

template<class _Ty1,
	class _Ty2>
	inline void _Do_enable(
		_Ty1 *_Ptr,
		enable_shared_from_this<_Ty2> *_Es,
		_Ref_count_base *_Refptr)
	{	// reset internal weak pointer
	_Es->_Wptr._Resetw(_Ptr, _Refptr);
	}
	}	// namespace tr1
_STD_END
 #endif /* _HAS_TR1 */

 #if _HAS_CPP0X
_STD_BEGIN
	// TEMPLATE CLASS unique_pointer AND HELPERS

	// TEMPLATE CLASS default_delete
template<class _Ty>
	struct default_delete
	{	// default deleter for unique_ptr
	typedef default_delete<_Ty> _Myt;

	default_delete()
		{	// default construct
		}

	template<class _Ty2>
		default_delete(const default_delete<_Ty2>&)
		{	// construct from another default_delete
		}

	void operator()(_Ty *_Ptr) const
		{	// delete a pointer
		if (0 < sizeof (_Ty))	// won't compile for incomplete type
			delete _Ptr;
		}
	};

template<class _Ty>
	struct default_delete<_Ty[]>
	{	// default deleter for unique_ptr to array of unknown size
	typedef default_delete<_Ty> _Myt;

	default_delete()
		{	// default construct
		}

	void operator()(_Ty *_Ptr) const
		{	// delete a pointer
		if (0 < sizeof (_Ty))	// won't compile for incomplete type
			delete[] _Ptr;
		}

	template<class _Other>
		void operator()(_Other *) const;	// not defined
	};

	// FUNCTION _Has_pointer_type
_STD tr1::_No _Has_pointer_type(...);

template<class _Ty>
	_STD tr1::_Yes _Has_pointer_type(_Ty *,
		typename _Ty::pointer * = 0);

template<class _Ty,
	class _Dx,
	bool>
	struct _Hold_pointer_type
	{	// wraps pointer type when _Dx::pointer absent
	typedef _Ty *pointer;
	};

template<class _Ty,
	class _Dx>
	struct _Hold_pointer_type<_Ty, _Dx, true>
	{	// wraps pointer type when _Dx::pointer present
	typedef typename _Dx::pointer pointer;
	};

 #define _DELETER_POINTER_TYPE(_Ty, _Dx) \
	typename _Hold_pointer_type<_Ty, _Dx, \
		_IS_YES(_Has_pointer_type((_Dx *)0))>::pointer

	// TEMPLATE CLASS _Unique_ptr_base
template<class _Ty,
	class _Dx,
	bool _Empty_deleter>
	class _Unique_ptr_base
	{	// stores pointer and deleter
public:
	typedef typename tr1::remove_reference<_Dx>::type _Dx_noref;
	typedef _DELETER_POINTER_TYPE(_Ty, _Dx_noref) pointer;

	_Unique_ptr_base(pointer _Ptr, _Dx _Dt)
		: _Myptr(_Ptr), _Mydel(_Dt)
		{	// construct with pointer and deleter
		}

	template<class _Ptr2,
		class _Dx2>
		_Unique_ptr_base(_Ptr2 _Ptr, _Dx2 _Dt)
		: _Myptr(_Ptr), _Mydel(_Dt)
		{	// construct with compatible pointer and deleter
		}

	_Dx_noref& get_deleter()
		{	// return reference to deleter
		return (_Mydel);
		}

	const _Dx_noref& get_deleter() const
		{	// return const reference to deleter
		return (_Mydel);
		}

	pointer _Myptr;	// the managed pointer
	_Dx _Mydel;		// the deleter
	};

template<class _Ty,
	class _Dx>
	class _Unique_ptr_base<_Ty, _Dx, true>
		: public _Dx
	{	// store pointer and empty deleter
public:
	typedef _Dx _Mybase;
	typedef typename tr1::remove_reference<_Dx>::type _Dx_noref;
	typedef _DELETER_POINTER_TYPE(_Ty, _Dx_noref) pointer;

	_Unique_ptr_base(pointer _Ptr, _Dx _Dt)
		: _Myptr(_Ptr), _Mybase(_Dt)
		{	// construct with pointer and deleter
		}

	template<class _Ptr2,
		class _Dx2>
		_Unique_ptr_base(_Ptr2 _Ptr, _Dx2 _Dt)
		: _Myptr(_Ptr), _Mybase(_Dt)
		{	// construct with compatible pointer and deleter
		}

	_Dx_noref& get_deleter()
		{	// return reference to deleter
		return (*this);
		}

	const _Dx_noref& get_deleter() const
		{	// return const reference to deleter
		return (*this);
		}

	pointer _Myptr;	// the managed pointer
	};

	// TEMPLATE CLASS unique_ptr SCALAR
template<class _Ty,
	class _Dx>	// = default_delete<_Ty>
	class unique_ptr
		: public _Unique_ptr_base<_Ty, _Dx,
			tr1::is_empty<_Dx>::value
				|| tr1::is_same<default_delete<_Ty>, _Dx>::value>
	{	// non-copyable pointer to an object
public:
	typedef unique_ptr<_Ty, _Dx> _Myt;
	typedef _Unique_ptr_base<_Ty, _Dx,
		tr1::is_empty<_Dx>::value
			|| tr1::is_same<default_delete<_Ty>, _Dx>::value> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	unique_ptr()
		: _Mybase(pointer(), _Dx())
		{	// default construct
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

 #if defined(_NATIVE_NULLPTR_SUPPORTED) \
	&& !defined(_DO_NOT_USE_NULLPTR_IN_STL)
	unique_ptr(_STD nullptr_t)
		: _Mybase(pointer(), _Dx())
		{	// null pointer construct
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	_Myt& operator=(_STD nullptr_t)
		{	// assign a null pointer
		reset();
		return (*this);
		}
 #endif /* defined(_NATIVE_NULLPTR_SUPPORTED) etc. */

	explicit unique_ptr(pointer _Ptr)
		: _Mybase(_Ptr, _Dx())
		{	// construct with pointer
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	unique_ptr(pointer _Ptr,
		typename _If<tr1::is_reference<_Dx>::value, _Dx,
			const typename tr1::remove_reference<_Dx>::type&>::_Type _Dt)
		: _Mybase(_Ptr, _Dt)
		{	// construct with pointer and (maybe const) deleter&
		}

	unique_ptr(pointer _Ptr, typename tr1::remove_reference<_Dx>::type&& _Dt)
		: _Mybase(_Ptr, _STD move(_Dt))
		{	// construct by moving deleter
//		static_assert(!tr1::is_reference<_Dx>::value,
//			"unique_ptr constructed with reference to rvalue deleter");
		}

	unique_ptr(unique_ptr&& _Right)
		: _Mybase(_Right.release(),
			_STD forward<_Dx>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

	template<class _Ty2,
		class _Dx2>
		unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right)
			: _Mybase(_Right.release(),
				_STD forward<_Dx2>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

	template<class _Ty2,
		class _Dx2>
		_Myt& operator=(unique_ptr<_Ty2, _Dx2>&& _Right)
		{	// assign by moving _Right
		reset(_Right.release());
		this->get_deleter() = _STD move(_Right.get_deleter());
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right)
		{	// assign by moving _Right
		if (this != &_Right)
			{	// different, do the move
			reset(_Right.release());
			this->get_deleter() = _STD move(_Right.get_deleter());
			}
		return (*this);
		}

	void swap(_Myt&& _Right)
		{	// swap elements
		if (this != &_Right)
			{	// different, do the swap
			_Swap_adl(this->_Myptr, _Right._Myptr);
			_Swap_adl(this->get_deleter(),
				_Right.get_deleter());
			}
		}

	void swap(_Myt& _Right)
		{	// swap elements
		_Swap_adl(this->_Myptr, _Right._Myptr);
		_Swap_adl(this->get_deleter(),
			_Right.get_deleter());
		}

	~unique_ptr()
		{	// destroy the object
		_Delete();
		}

	typename tr1::add_reference<_Ty>::type operator*() const
		{	// return reference to object
		return (*this->_Myptr);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (&**this);
		}

	pointer get() const
		{	// return pointer to object
		return (this->_Myptr);
		}

	_OPERATOR_BOOL() const
		{	// test for non-null pointer
		return (this->_Myptr != pointer() ? _CONVERTIBLE_TO_TRUE : 0);
		}

	pointer release()
		{	// yield ownership of pointer
		pointer _Ans = this->_Myptr;
		this->_Myptr = pointer();
		return (_Ans);
		}

	void reset(pointer _Ptr = pointer())
		{	// establish new pointer
		if (_Ptr != this->_Myptr)
			{	// different pointer, delete old and reassign
			_Delete();
			this->_Myptr = _Ptr;
			}
		}

private:
	void _Delete()
		{	// delete the pointer
		if (this->_Myptr != pointer())
			this->get_deleter()(this->_Myptr);
		}

	unique_ptr(const _Myt&);	// not defined
	template<class _Ty2,
		class _Dx2>
		unique_ptr(const unique_ptr<_Ty2, _Dx2>&);	// not defined

	_Myt& operator=(const _Myt&);	// not defined
	template<class _Ty2,
		class _Dx2>
		_Myt& operator=(const unique_ptr<_Ty2, _Dx2>&);	// not defined
	};

	// TEMPLATE CLASS unique_ptr ARRAY
template<class _Ty,
	class _Dx>
	class unique_ptr<_Ty[], _Dx>
		: public _Unique_ptr_base<_Ty, _Dx,
			tr1::is_empty<_Dx>::value
				|| tr1::is_same<default_delete<_Ty[]>, _Dx>::value>
	{	// non-copyable pointer to an array object
public:
	typedef unique_ptr<_Ty[], _Dx> _Myt;
	typedef _Unique_ptr_base<_Ty, _Dx,
		tr1::is_empty<_Dx>::value
			|| tr1::is_same<default_delete<_Ty[]>, _Dx>::value> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	unique_ptr()
		: _Mybase(pointer(), _Dx())
		{	// default construct
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	explicit unique_ptr(pointer _Ptr)
		: _Mybase(_Ptr, _Dx())
		{	// construct with pointer
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	unique_ptr(pointer _Ptr,
		typename _If<tr1::is_reference<_Dx>::value, _Dx,
			const typename tr1::remove_reference<_Dx>::type&>::_Type _Dt)
		: _Mybase(_Ptr, _Dt)
		{	// construct with pointer and (maybe const) deleter&
		}

public:
	unique_ptr(pointer _Ptr, typename tr1::remove_reference<_Dx>::type&& _Dt)
		: _Mybase(_Ptr, _STD move(_Dt))
		{	// construct by moving deleter
//		static_assert(!tr1::is_reference<_Dx>::value,
//			"unique_ptr constructed with reference to rvalue deleter");
		}

	unique_ptr(unique_ptr&& _Right)
		: _Mybase(_Right.release(),
			_STD forward<_Dx>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

private:
	template<class _Ty2,
		class _Dx2>
		unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right);	// not defined

	template<class _Ty2,
		class _Dx2>
		_Myt& operator=(unique_ptr<_Ty2, _Dx2>&& _Right);	// not defined

public:
	_Myt& operator=(_Myt&& _Right)
		{	// assign by moving _Right
		if (this != &_Right)
			{	// different, do the swap
			reset(_Right.release());
			this->get_deleter() = _STD move(_Right.get_deleter());
			}
		return (*this);
		}

	void swap(_Myt&& _Right)
		{	// swap elements
		if (this != &_Right)
			{	// different, do the move
			_Swap_adl(this->_Myptr, _Right._Myptr);
			_Swap_adl(this->get_deleter(),
				_Right.get_deleter());
			}
		}

 #if defined(_NATIVE_NULLPTR_SUPPORTED) \
	&& !defined(_DO_NOT_USE_NULLPTR_IN_STL)
	unique_ptr(_STD nullptr_t)
		: _Mybase(pointer(), _Dx())
		{	// null pointer construct
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	_Myt& operator=(_STD nullptr_t)
		{	// assign a null pointer
		reset();
		return (*this);
		}

	void reset(_STD nullptr_t)
		{	// establish new null pointer
		if (this->_Myptr != 0)
			{	// different pointer, delete old and reassign
			_Delete();
			this->_Myptr = 0;
			}
		}
 #endif /* defined(_NATIVE_NULLPTR_SUPPORTED) etc. */

	void swap(_Myt& _Right)
		{	// swap elements
		_Swap_adl(this->_Myptr, _Right._Myptr);
		_Swap_adl(this->get_deleter(), _Right.get_deleter());
		}

	~unique_ptr()
		{	// destroy the object
		_Delete();
		}

	typename tr1::add_reference<_Ty>::type operator[](size_t _Idx) const
		{	// return reference to object
		return (this->_Myptr[_Idx]);
		}

	pointer get() const
		{	// return pointer to object
		return (this->_Myptr);
		}

	_OPERATOR_BOOL() const
		{	// test for non-null pointer
		return (this->_Myptr != 0 ? _CONVERTIBLE_TO_TRUE : 0);
		}

	pointer release()
		{	// yield ownership of pointer
		pointer _Ans = this->_Myptr;
		this->_Myptr = pointer();
		return (_Ans);
		}

	void reset(pointer _Ptr = pointer())
		{	// establish new pointer
		if (_Ptr != this->_Myptr)
			{	// different pointer, delete old and reassign
			_Delete();
			this->_Myptr = _Ptr;
			}
		}

private:
	template<class _Ptr2>
		explicit unique_ptr(_Ptr2);	// not defined

	template<class _Ptr2,
		class _Dx2>
		unique_ptr(_Ptr2, _Dx2);	// not defined

	unique_ptr(const _Myt&);	// not defined
	template<class _Ty2,
		class _Dx2>
		unique_ptr(const unique_ptr<_Ty2, _Dx2>&);	// not defined

	_Myt& operator=(const _Myt&);	// not defined
	template<class _Ty2,
		class _Dx2>
		_Myt& operator=(const unique_ptr<_Ty2, _Dx2>&);	// not defined

	template<class _Ptr2>
		void reset(_Ptr2);	// not defined

	void _Delete()
		{	// delete the pointer
		this->get_deleter()(this->_Myptr);
		}
	};

template<class _Ty,
	class _Dx>
	void swap(unique_ptr<_Ty, _Dx>& _Left,
		unique_ptr<_Ty, _Dx>& _Right)
	{	// swap _Left with _Right
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Dx>
	void swap(unique_ptr<_Ty, _Dx>& _Left,
		unique_ptr<_Ty, _Dx>&& _Right)
	{	// swap _Left with rvalue _Right
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Dx>
	void swap(unique_ptr<_Ty, _Dx>&& _Left,
		unique_ptr<_Ty, _Dx>& _Right)
	{	// swap _Right with rvalue _Left
	_Right.swap(_Left);
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left equals _Right
	return (_Left.get() == _Right.get());
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left doesn't equal _Right
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left precedes _Right
	return (_Left.get() < _Right.get());
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left doesn't precede _Right
	return (!(_Left < _Right));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Right precedes _Left
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Right doesn't precede _Left
	return (!(_Right < _Left));
	}

		// GARBAGE COLLECTION
	namespace pointer_safety {
enum pointer_safety {	// names for generic error codes
	relaxed,
	preferred,
	strict
	};
	}	// namespace pointer_safety

typedef pointer_safety::pointer_safety _Pointer_safety;

inline void declare_reachable(void *)
	{	// increment pointer reachable count
	}

template<class _Ty> inline
	_Ty *undeclare_reachable(_Ty *_Ptr)
	{	// decrement pointer reachable count
	return (_Ptr);
	}

inline void declare_no_pointers(char *, size_t)
	{	// declare region to be pointer free
	}

inline void undeclare_no_pointers(char *, size_t)
	{	// undeclare region to be pointer free
	}

inline _Pointer_safety get_pointer_safety()
	{	// get pointer safety status
	return (pointer_safety::relaxed);
	}

 #if _HAS_TR1_IMPORTS
using tr1::allocate_shared;
using tr1::bad_weak_ptr;
using tr1::const_pointer_cast;
using tr1::dynamic_pointer_cast;
using tr1::enable_shared_from_this;
using tr1::get_deleter;
using tr1::make_shared;
using tr1::shared_ptr;
using tr1::static_pointer_cast;
using tr1::swap;
using tr1::weak_ptr;
 #endif /* _HAS_TR1_IMPORTS */

		// TEMPLATE STRUCT owner_less
template<class _Ty>
	struct owner_less;	// not defined

template<class _Ty>
	struct owner_less<shared_ptr<_Ty> >
		: public binary_function<shared_ptr<_Ty>, shared_ptr<_Ty>, bool>
	{	// functor for owner_before
	bool operator()(const shared_ptr<_Ty>& _Left,
		const shared_ptr<_Ty>& _Right) const
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	bool operator()(const shared_ptr<_Ty>& _Left,
		const weak_ptr<_Ty>& _Right) const
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	bool operator()(const weak_ptr<_Ty>& _Left,
		const shared_ptr<_Ty>& _Right) const
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}
	};

template<class _Ty>
	struct owner_less<weak_ptr<_Ty> >
		: public binary_function<weak_ptr<_Ty>, weak_ptr<_Ty>, bool>
	{	// functor for owner_before
	bool operator()(const weak_ptr<_Ty>& _Left,
		const weak_ptr<_Ty>& _Right) const
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	bool operator()(const weak_ptr<_Ty>& _Left,
		const shared_ptr<_Ty>& _Right) const
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	bool operator()(const shared_ptr<_Ty>& _Left,
		const weak_ptr<_Ty>& _Right) const
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}
	};
_STD_END
 #endif /* _HAS_CPP0X */

 #pragma pop_macro("new")

 #pragma warning(pop)
 #pragma pack(pop)

#endif /* RC_INVOKED */
#endif /* _MEMORY_ */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */

/*
 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.20:0009 */
